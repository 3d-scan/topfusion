#pragma once

#include "Math.h"
#include <tfusion/types.hpp>

namespace tfusion
{
	/** \brief
		Stores the render state used by the SceneReconstruction
		and Visualisation engines.
		*/
	class RenderState
	{
	public:
		/** @brief
		Gives the raycasting operations an idea of the
		depth range to cover

		Each pixel contains an expected minimum and maximum
		depth. The raycasting step would use this
		information to reduce the range for searching an
		intersection with the actual surface. Should be
		updated by a tfusion::Engine::VisualisationEngine
		before any raycasting operation.
		*/
		cuda::DeviceArray2D<Vector2f> renderingRangeImage;

		/** @brief
		Float rendering output of the scene, containing the 3D
		locations in the world generated by the raycast.

		This is typically created as a by-product of
		raycasting operations.
		*/
		cuda::DeviceArray2D<Vector4f> raycastResult;

		cuda::DeviceArray2D<Vector4f> forwardProjection;
		cuda::DeviceArray2D<int> fwdProjMissingPoints;
		int noFwdProjMissingPoints;

		cuda::DeviceArray2D<Vector4u> raycastImage;

		RenderState(const Vector2i &imgSize, float vf_min, float vf_max, MemoryDeviceType memoryType)
		{
			int x = imgSize.x;
			int y = imgSize.y;
			renderingRangeImage.create(y,x);
			raycastResult.create(y,x);
			forwardProjection.create(y,x);
			fwdProjMissingPoints.create(y,x);
			raycastImage.create(y,x);
			
			Vector2f buffImage = (Vector2f*)malloc(x*y*sizeof(Vector2f));

			Vector2f v_lims(vf_min, vf_max);

			for(int i = 0;i < imgSize.x * imgSize.y;i++) buffImage[i] = v_lims;

			renderingRangeImage.upload(buffImage,x*sizeof(Vector2f),y,x);
			delete buffImage;

			noFwdProjMissingPoints = 0;
		}

		virtual ~RenderState()
		{
			delete renderingRangeImage;
			delete raycastResult;
			delete forwardProjection;
			delete fwdProjMissingPoints;
			delete raycastImage;
		}
	};
}

#endif
