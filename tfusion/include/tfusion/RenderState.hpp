#pragma once

#include "Math.h"

namespace tfusion
{
	/** \brief
		Stores the render state used by the SceneReconstruction
		and Visualisation engines.
		*/
	class RenderState
	{
	public:
		/** @brief
		Gives the raycasting operations an idea of the
		depth range to cover

		Each pixel contains an expected minimum and maximum
		depth. The raycasting step would use this
		information to reduce the range for searching an
		intersection with the actual surface. Should be
		updated by a tfusion::Engine::VisualisationEngine
		before any raycasting operation.
		*/
		cuda::DeviceArray2D<Vector2f> *renderingRangeImage;

		/** @brief
		Float rendering output of the scene, containing the 3D
		locations in the world generated by the raycast.

		This is typically created as a by-product of
		raycasting operations.
		*/
		cuda::DeviceArray2D<Vector4f> *raycastResult;

		cuda::DeviceArray2D<Vector4f> *forwardProjection;
		cuda::DeviceArray2D<int> *fwdProjMissingPoints;
		int noFwdProjMissingPoints;

		cuda::DeviceArray2D<Vector4u> *raycastImage;

		RenderState(const Vector2i &imgSize, float vf_min, float vf_max, MemoryDeviceType memoryType)
		{
			renderingRangeImage = new cuda::DeviceArray2D<Vector2f>(imgSize, memoryType);
			raycastResult = new cuda::DeviceArray2D<Vector4f>(imgSize, memoryType);
			forwardProjection = new cuda::DeviceArray2D<Vector4f>(imgSize, memoryType);
			fwdProjMissingPoints = new cuda::DeviceArray2D<int>(imgSize, memoryType);
			raycastImage = new cuda::DeviceArray2D<Vector4u>(imgSize, memoryType);

			cuda::DeviceArray2D<Vector2f> *buffImage = new cuda::DeviceArray2D<Vector2f>(imgSize, MEMORYDEVICE_CPU);

			Vector2f v_lims(vf_min, vf_max);
			for (int i = 0; i < imgSize.x * imgSize.y; i++) buffImage->GetData(MEMORYDEVICE_CPU)[i] = v_lims;

			if (memoryType == MEMORYDEVICE_CUDA)
			{
#ifndef COMPILE_WITHOUT_CUDA
				renderingRangeImage->SetFrom(buffImage, ORUtils::MemoryBlock<Vector2f>::CPU_TO_CUDA);
#endif
			}
			else renderingRangeImage->SetFrom(buffImage, ORUtils::MemoryBlock<Vector2f>::CPU_TO_CPU);

			delete buffImage;

			noFwdProjMissingPoints = 0;
		}

		virtual ~RenderState()
		{
			delete renderingRangeImage;
			delete raycastResult;
			delete forwardProjection;
			delete fwdProjMissingPoints;
			delete raycastImage;
		}
	};
}

#endif
